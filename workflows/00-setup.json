{
  "workflow_metadata": {
    "workflow_id": "00-setup",
    "name": "Setup Workflow",
    "version": "1.0.0",
    "description": "Initialize system, configure paths, set up environment and foundational documents",
    "created_from": "decision_flow.json v2.5.0 - extracted Arch-00, Arch-01, and initialization logic",
    "last_updated": "2025-10-24",
    "purpose": "Establish all prerequisites for architecture and development workflows"
  },
  "path_configuration": {
    "description": "Critical path setup - all paths must be absolute for tool invocations",
    "required_paths": {
      "reflow_root": {
        "description": "Where reflow tooling is installed (e.g., /home/user/dev/reflow)",
        "must_contain": ["tools/", "templates/", "definitions/", "workflows/", "workflow_steps/"],
        "verification": "Check for presence of core directories",
        "stored_in": "system context/working_memory.json"
      },
      "system_root": {
        "description": "Where the system being developed is located (e.g., /home/user/projects/my_system)",
        "must_contain": ["context/", "specs/", "docs/"],
        "created_by": "This workflow",
        "stored_in": "system context/working_memory.json"
      },
      "workflow_steps_path": {
        "description": "Path to workflow step definitions",
        "default": "{reflow_root}/workflow_steps",
        "stored_in": "system context/working_memory.json"
      },
      "tools_path": {
        "description": "Path to reflow tools",
        "default": "{reflow_root}/tools",
        "stored_in": "system context/working_memory.json"
      },
      "templates_path": {
        "description": "Path to reflow templates",
        "default": "{reflow_root}/templates",
        "stored_in": "system context/working_memory.json"
      }
    },
    "path_best_practices": [
      "Store reflow tools in one location (e.g., ~/dev/reflow/)",
      "Store each system in its own location (e.g., ~/projects/system_name/)",
      "Use absolute paths when invoking tools to avoid confusion",
      "Within system files, always use relative paths for portability",
      "Never assume systems are in reflow/systems/ directory"
    ]
  },
  "entry_points": {
    "new_system": {
      "id": "new_system",
      "description": "Starting a brand new system or concept",
      "trigger": "User wants to create a new system from scratch",
      "first_step": "S-01"
    },
    "new_concept_or_system": {
      "id": "new_concept_or_system",
      "description": "New concept that may become one or more systems",
      "trigger": "User has a new idea to develop",
      "first_step": "S-01"
    },
    "system_of_systems": {
      "id": "system_of_systems",
      "description": "Multi-system integration project",
      "trigger": "User wants to create a system-of-systems architecture",
      "first_step": "S-01",
      "optional_step": "S-04"
    }
  },
  "context_management": {
    "description": "Prevent context drift and token exhaustion during workflow execution",
    "template_reference": "See templates/context_management_template.json for complete details",
    "rag_enhanced_mode": {
      "description": "RECOMMENDED - Use RAG for automatic context injection and degradation detection",
      "setup": "Initialize in S-03-A05 (Setup workflow)",
      "benefits": "Automatic retrieval, degradation detection, systematic rule enforcement",
      "usage": "Use rag_agent_wrapper.py to wrap queries: python3 {reflow_root}/tools/rag_agent_wrapper.py {system_root} wrap --query 'your query' --strategy on_step_start",
      "fallback": "If RAG not set up, use manual context management below"
    },
    "operations_counter": {
      "threshold": 5,
      "tracking_location": "context/working_memory.json (operations_since_refresh field)",
      "rule": "Increment after each real operation (file creation, tool execution, artifact generation)",
      "refresh_trigger": "When >= 5, execute refresh sequence immediately",
      "rag_alternative": "RAG provides automatic periodic refresh every 4 operations or 12 minutes"
    },
    "degradation_signals_watch_for": [
      "Asking about system name (it's in working_memory.json)",
      "Forgetting current step",
      "Working in wrong directory (pwd != system_root)",
      "Using wrong template format",
      "Repetitive errors (same error 2+ times)",
      "Generating unwanted reports or summaries"
    ],
    "degradation_detection_tools": {
      "rag_automatic": "If RAG enabled, use: python3 {reflow_root}/tools/rag_agent_wrapper.py {system_root} analyze --response response.txt",
      "manual": "If RAG not enabled, watch for degradation signals above and manually trigger refresh"
    },
    "refresh_sequence_summary": [
      "1. PAUSE - Stop all operations",
      "2. VERIFY PWD - Confirm in correct directory",
      "3. SAVE STATE - Update working_memory.json and step_progress_tracker.json",
      "4. RELOAD - Read workflow file, definitions, templates (OR use RAG wrapper for automatic injection)",
      "5. READ - current_focus.md and step_progress_tracker.json",
      "6. CONFIRM - State system name, workflow, step, next action",
      "7. RESET - Set operations_since_refresh = 0",
      "8. RESUME - Continue with confirmed action"
    ],
    "pre_operation_checklist": [
      "Verify pwd equals system_root",
      "Read current_focus.md (OR use RAG wrapper for automatic context)",
      "Read step_progress_tracker.json",
      "Verify action matches current step",
      "Check operations_since_refresh <= 4"
    ],
    "rag_tools_available": [
      "rag_agent_wrapper.py wrap - Wrap query with relevant context",
      "rag_agent_wrapper.py analyze - Detect degradation in responses",
      "rag_agent_wrapper.py validate - Pre-operation validation",
      "rag_agent_wrapper.py refresh - Force context refresh",
      "generate_rag_embeddings.py --force-rebuild - Rebuild embeddings if workflows updated"
    ]
  },
  "self_improvement": {
    "description": "Continuous workflow improvement through observation and metrics",
    "template_reference": "See templates/self_improvement_template.json for complete details",
    "during_execution": {
      "observe": ["Time efficiency", "Error patterns", "Quality gate effectiveness", "Tool performance", "Documentation gaps"],
      "document": "Log observations to context/process_log.md with timestamps",
      "track_metrics": "Update context/workflow_metrics.json after each step"
    },
    "after_completion": {
      "retrospective_file": "context/workflow_retrospective_00-setup_{date}.md",
      "key_questions": [
        "What worked well?",
        "What was confusing?",
        "What could be automated?",
        "What took longer than expected?"
      ],
      "improvement_submission": "Add entries to WORKFLOW_IMPROVEMENTS_BACKLOG.md"
    }
  },
  "workflow_steps": [
    {
      "step_id": "S-01",
      "name": "Path Configuration",
      "description": "Configure all required paths for reflow operation",
      "phase": "initialization",
      "step_file": "workflow_steps/setup/S-01-PathConfiguration.json",
      "actions": [
        {
          "action_id": "S-01-A01",
          "description": "Identify and validate reflow_root path",
          "verification": "Ensure reflow_root contains tools/, templates/, definitions/, workflows/",
          "store_in": "context/working_memory.json under paths.reflow_root"
        },
        {
          "action_id": "S-01-A02",
          "description": "Identify or create system_root path",
          "verification": "Confirm system directory exists or create it",
          "store_in": "context/working_memory.json under paths.system_root"
        },
        {
          "action_id": "S-01-A03",
          "description": "Derive and store all tool paths",
          "details": "Calculate paths.tools_path, paths.templates_path, paths.workflow_steps_path, paths.definitions_path",
          "store_in": "context/working_memory.json"
        },
        {
          "action_id": "S-01-A04",
          "description": "Run validate_reflow_setup.py",
          "command_pattern": "python3 {reflow_root}/tools/validate_reflow_setup.py {system_root}",
          "success_criteria": "All validation checks pass"
        }
      ],
      "tools_used": ["validate_reflow_setup.py"],
      "outputs": ["context/working_memory.json with complete path configuration"],
      "gates": [],
      "next_step": "S-01A"
    },
    {
      "step_id": "S-01A",
      "name": "Architectural Framework Selection",
      "description": "Critically analyze and select the architectural framework appropriate for the system being modeled",
      "phase": "initialization",
      "step_file": "workflow_steps/setup/S-01A-FrameworkSelection.json",
      "rationale": "Framework selection is an ARCHITECTURAL DECISION, not a configuration choice. Wrong framework = wrong insights. This step requires EXPLICIT ANALYSIS of all frameworks against system semantics and user confirmation before proceeding.",
      "critical_lesson": "LESSON-01: Do NOT default to UAF! Analyze system semantics (state machines? services? agents? species?) against ALL frameworks. Framework choice determines which NetworkX analyses are available.",
      "actions": [
        {
          "action_id": "S-01A-A01",
          "description": "Analyze system domain and characteristics with semantic matching",
          "purpose": "Understand system semantics BEFORE selecting framework - match abstractions, not just domain",
          "rationale": "LESSON-04: Framework abstractions must match system semantics. Workflows are state machines (not services), even though both could be 'engineered systems'. Wrong abstraction = wrong insights.",
          "llm_instructions": [
            "Ask user to describe the system in their own words",
            "Apply semantic matching questionnaire (below) to understand system nature",
            "Document answers for framework comparison"
          ],
          "semantic_matching_questionnaire": {
            "question_1": {
              "question": "What are your primary entities (nodes)?",
              "answers_map_to": {
                "Services that communicate via APIs": "UAF framework",
                "States in a process with transitions": "Decision Flow framework",
                "Agents with relationships": "Social Network framework",
                "Species in an ecosystem": "Ecological framework",
                "Genes, proteins, or molecules": "Systems Biology framework",
                "Adaptive agents that learn": "Complex Adaptive Systems framework"
              },
              "critical": "Match entity semantics, not just domain. A workflow step is a STATE, not a SERVICE."
            },
            "question_2": {
              "question": "What are your connections (edges)?",
              "answers_map_to": {
                "API calls or data interfaces": "UAF framework",
                "State transitions with conditions": "Decision Flow framework",
                "Social relationships or interactions": "Social Network framework",
                "Energy/matter flow or species interactions": "Ecological framework",
                "Molecular interactions (activation, inhibition)": "Systems Biology framework",
                "Adaptive interactions with feedback": "Complex Adaptive Systems framework"
              },
              "critical": "Edges represent different things in each framework. Workflow transitions ≠ API calls."
            },
            "question_3": {
              "question": "Do edges have conditions or branching?",
              "answers_map_to": {
                "Yes, if/else routing or decision points": "Decision Flow framework (conditional transitions)",
                "Yes, but based on agent decisions": "Social Network or CAS framework",
                "No, always connected": "UAF, Social Network (static connections)",
                "Yes, based on environmental factors": "Ecological or Systems Biology framework"
              }
            },
            "question_4": {
              "question": "Are cycles expected behavior or errors?",
              "answers_map_to": {
                "Expected - feedback loops are essential": "Systems Biology, CAS, Ecological (regulatory feedback)",
                "Expected - rework loops are normal": "Decision Flow (validation failures, retries)",
                "Errors - circular dependencies are bad": "UAF (service dependencies should be acyclic)",
                "Neither - cycles not relevant": "Consider simpler modeling approach"
              },
              "critical": "Cycle semantics determine framework choice. UAF cycles = bugs. Biology cycles = features."
            },
            "question_5": {
              "question": "Do you need to analyze flow, throughput, or bottlenecks?",
              "answers_map_to": {
                "Yes, need to find workflow bottlenecks": "Decision Flow (requires edge weights: probabilities)",
                "Yes, need to track energy flow": "Ecological (requires edge weights: energy transfer rates)",
                "Yes, need to analyze reaction rates": "Systems Biology (requires edge weights: reaction rates)",
                "No, just need connectivity analysis": "Any framework works (centrality, community, etc.)"
              },
              "critical": "Flow analysis REQUIRES edge weights. If you need flow, choose framework that supports weights."
            },
            "question_6": {
              "question": "What is the system's primary behavior?",
              "answers_map_to": {
                "Sequential processing with decision points": "Decision Flow framework",
                "Services responding to requests": "UAF framework",
                "Agents interacting and influencing each other": "Social Network or CAS framework",
                "Species competing and cooperating": "Ecological framework",
                "Molecules regulating each other": "Systems Biology framework",
                "Emergent behavior from simple rules": "Complex Adaptive Systems framework"
              }
            }
          },
          "semantic_matching_decision_tree": {
            "start": "What are your nodes?",
            "if_states": "Are transitions conditional?",
            "if_conditional_transitions": "→ Decision Flow Framework",
            "if_sequential_only": "→ Decision Flow or UAF (check if states vs services)",
            "if_services": "Do services have human users?",
            "if_services_with_users": "→ UAF with IT requirements (security, deployment, UX)",
            "if_services_internal": "→ UAF (simpler security acceptable)",
            "if_agents": "Do agents adapt and learn?",
            "if_adaptive_agents": "→ Complex Adaptive Systems",
            "if_static_agents": "→ Social Network Analysis",
            "if_species": "→ Ecological Systems Framework",
            "if_molecules": "→ Systems Biology Framework",
            "if_hybrid": "→ Custom Framework (research domain)"
          },
          "examples_correct_vs_incorrect": {
            "correct": [
              "Microservices system → UAF (services communicating via APIs)",
              "Reflow workflows → Decision Flow (states with conditional transitions)",
              "Gene regulatory network → Systems Biology (molecular interactions)",
              "Corporate org chart → Social Network (people with relationships)",
              "Food web → Ecological (species with predation/competition)",
              "Stock market → CAS (adaptive agents with emergent behavior)"
            ],
            "incorrect": [
              "❌ Reflow workflows → UAF (WRONG: steps ≠ services, misses decision logic)",
              "❌ Social network → UAF (WRONG: relationships ≠ interfaces)",
              "❌ Food web → UAF (WRONG: predation ≠ API calls)",
              "❌ Gene network → Social Network (WRONG: molecular regulation ≠ social relationships)"
            ]
          },
          "output": "System characteristics summary with semantic matching answers"
        },
        {
          "action_id": "S-01A-A02",
          "description": "Analyze ALL frameworks against system characteristics",
          "purpose": "Evaluate EVERY framework, not just pick one",
          "llm_instructions": [
            "Load definitions/framework_registry.json",
            "For EACH of the 7 frameworks (UAF, Decision Flow, Systems Biology, Social Network, Ecological, CAS, Custom):",
            "  - Evaluate: Does system domain match framework domain?",
            "  - Evaluate: Do system entities match framework node types?",
            "  - Evaluate: Do system connections match framework edge types?",
            "  - Evaluate: Which NetworkX analyses does this framework enable?",
            "  - Evaluate: What insights would this framework reveal?",
            "  - Evaluate: What insights would this framework MISS?",
            "Create comparison table showing each framework's fit"
          ],
          "required_fields_to_check": [
            "framework.domain",
            "framework.node_types",
            "framework.edge_types",
            "framework.recommended_analyses",
            "framework.edge_schema (does it support weights?)"
          ],
          "output": "Framework analysis comparison table"
        },
        {
          "action_id": "S-01A-A03",
          "description": "Map NetworkX analyses to each framework",
          "purpose": "Show which analyses each framework enables/blocks",
          "llm_instructions": [
            "For each framework, list which NetworkX analyses are:",
            "  - AVAILABLE: Can be run with this framework",
            "  - BLOCKED: Cannot be run (e.g., flow analysis requires edge weights)",
            "  - SEMANTIC: Have different meaning (cycles = rework loops vs circular deps)",
            "Create NetworkX analysis availability matrix",
            "Highlight analyses that are HIGH priority for this system"
          ],
          "example_output": {
            "uaf": {
              "flow_analysis": "BLOCKED - No edge weights support",
              "cycle_detection": "AVAILABLE - Cycles indicate circular dependencies (BAD)",
              "dag_analysis": "AVAILABLE - Verify no circular service dependencies"
            },
            "decision_flow": {
              "flow_analysis": "AVAILABLE - Uses transition probabilities to find critical paths",
              "cycle_detection": "AVAILABLE - Cycles indicate rework loops (EXPECTED)",
              "dag_analysis": "AVAILABLE - Find sequential workflow paths"
            }
          },
          "output": "NetworkX analysis availability matrix"
        },
        {
          "action_id": "S-01A-A04",
          "description": "Score and recommend framework with objective criteria",
          "purpose": "Present LLM's framework recommendation to user with objective scoring",
          "rationale": "LESSON-06: Use objective scoring criteria to make framework selection transparent and defensible",
          "llm_instructions": [
            "Based on steps A01-A03 analysis, score EACH framework on 5 criteria",
            "Use scoring rubric below to calculate total scores",
            "Select framework with HIGHEST total score",
            "Prepare recommendation message including:",
            "  1. Recommended framework (highest score)",
            "  2. Score breakdown showing WHY this framework won",
            "  3. Comparison with 2nd and 3rd place frameworks",
            "  4. WHAT insights this framework will reveal",
            "  5. WHICH NetworkX analyses will be enabled",
            "Format as clear, structured message with scores visible"
          ],
          "framework_scoring_rubric": {
            "criterion_1_domain_match": {
              "name": "Domain Match",
              "weight": 2.0,
              "description": "How well does the framework's target domain match the system's domain?",
              "scoring": {
                "10": "Perfect match (e.g., microservices → UAF, workflows → Decision Flow)",
                "7-9": "Good match with minor misalignment",
                "4-6": "Partial match, framework can work but not ideal",
                "1-3": "Poor match, framework not designed for this domain",
                "0": "Complete mismatch"
              }
            },
            "criterion_2_semantic_match": {
              "name": "Semantic Match",
              "weight": 2.5,
              "description": "Do system entities match framework node/edge abstractions?",
              "scoring": {
                "10": "Perfect semantic match (states → Decision Flow, services → UAF, species → Ecological)",
                "7-9": "Good match with reasonable interpretation",
                "4-6": "Forced fit, requires mental gymnastics",
                "1-3": "Poor fit, wrong abstractions (e.g., workflow steps as 'services')",
                "0": "Semantics completely incompatible"
              },
              "critical": "MOST IMPORTANT criterion. Wrong abstractions = wrong insights."
            },
            "criterion_3_analysis_match": {
              "name": "Required Analyses Availability",
              "weight": 2.0,
              "description": "Does framework enable the NetworkX analyses you need?",
              "scoring": {
                "10": "All required analyses available (e.g., need flow → framework has edge weights)",
                "7-9": "Most analyses available, workarounds possible",
                "4-6": "Some analyses available, significant gaps",
                "1-3": "Few analyses available, major limitations",
                "0": "Critical analyses blocked (e.g., need flow but no edge weights)"
              }
            },
            "criterion_4_edge_weight_feasibility": {
              "name": "Edge Weight Feasibility",
              "weight": 1.5,
              "description": "If framework requires edge weights, can you provide them?",
              "scoring": {
                "10": "Edge weights not needed OR easily obtainable (historical data, domain knowledge)",
                "7-9": "Can estimate weights with reasonable accuracy",
                "4-6": "Weights difficult to obtain, rough estimates only",
                "1-3": "Weights very difficult, mostly guessing",
                "0": "Cannot provide weights but framework requires them",
                "N/A": "Framework doesn't use edge weights (score 10 by default)"
              }
            },
            "criterion_5_complexity": {
              "name": "Framework Complexity",
              "weight": 1.0,
              "description": "Prefer simpler frameworks if they meet requirements equally well",
              "scoring": {
                "10": "Very simple, easy to understand and apply",
                "7-9": "Moderate complexity, manageable",
                "4-6": "Complex, requires significant learning",
                "1-3": "Very complex, steep learning curve",
                "0": "Extremely complex, not practical"
              },
              "note": "Only use as tiebreaker if scores are close"
            }
          },
          "scoring_process": {
            "step_1": "Score each framework on all 5 criteria (0-10 scale)",
            "step_2": "Multiply each score by its weight",
            "step_3": "Sum weighted scores to get total (max 80 points)",
            "step_4": "Select framework with highest total score",
            "step_5": "Document scores for transparency"
          },
          "example_scoring_output": {
            "system": "Reflow Workflow System",
            "frameworks_scored": {
              "decision_flow": {
                "total_score": "9.2/10 (73.6/80 points)",
                "breakdown": {
                  "domain_match": "10/10 × 2.0 = 20.0 (workflow system)",
                  "semantic_match": "10/10 × 2.5 = 25.0 (states, not services)",
                  "analysis_match": "9/10 × 2.0 = 18.0 (flow, cycles, paths all available)",
                  "edge_weight_feasibility": "8/10 × 1.5 = 12.0 (can estimate probabilities)",
                  "complexity": "8/10 × 1.0 = 8.0 (moderate)"
                },
                "recommendation": "✅ RECOMMENDED - Highest score, perfect semantic match"
              },
              "uaf": {
                "total_score": "4.2/10 (33.6/80 points)",
                "breakdown": {
                  "domain_match": "8/10 × 2.0 = 16.0 (engineered system)",
                  "semantic_match": "2/10 × 2.5 = 5.0 (services ≠ states)",
                  "analysis_match": "3/10 × 2.0 = 6.0 (DAG ok, but no flow)",
                  "edge_weight_feasibility": "2/10 × 1.5 = 3.0 (no weight support)",
                  "complexity": "8/10 × 1.0 = 8.0 (simple)"
                },
                "recommendation": "❌ NOT RECOMMENDED - Poor semantic match, missing flow analysis"
              },
              "complex_adaptive": {
                "total_score": "6.5/10 (52.0/80 points)",
                "breakdown": {
                  "domain_match": "7/10 × 2.0 = 14.0 (emergent behavior)",
                  "semantic_match": "6/10 × 2.5 = 15.0 (adaptive agents)",
                  "analysis_match": "7/10 × 2.0 = 14.0 (cycles, SCC available)",
                  "edge_weight_feasibility": "6/10 × 1.5 = 9.0 (interaction strength unclear)",
                  "complexity": "5/10 × 1.0 = 5.0 (complex)"
                },
                "recommendation": "⚠️ SECOND PLACE - Could work but less clear than Decision Flow"
              }
            }
          },
          "recommendation_template": {
            "recommended_framework": "framework_id (highest score)",
            "total_score": "X.X/10 (XX.X/80 points)",
            "score_breakdown": "Show weighted scores for all criteria",
            "comparison_with_alternatives": "Show 2nd and 3rd place scores",
            "rationale": "Why this framework won (semantic match, analysis availability)",
            "reveals": ["Insight 1", "Insight 2"],
            "enables_analyses": ["flow", "cycles", "centrality"],
            "alternatives_rejected": {
              "framework_name": "Rejected due to low score on [criterion]"
            }
          },
          "output": "Framework recommendation with objective scoring"
        },
        {
          "action_id": "S-01A-A05",
          "description": "Present recommendation to user and request confirmation",
          "purpose": "USER MUST EXPLICITLY CONFIRM framework selection",
          "user_prompt": {
            "message_format": "Framework Recommendation:\n\nRecommended: {framework_name}\n\nRationale:\n{rationale}\n\nThis framework reveals:\n{reveals_list}\n\nNetworkX analyses enabled:\n{enabled_analyses}\n\nAlternatives considered:\n{alternatives_rejected}\n\n⚠️ IMPORTANT: Framework selection determines entire analysis approach. Switching later requires re-doing all architecture files.\n\nConfirm: Proceed with {framework_name}? [Y/N]",
            "required": true,
            "blocking": true
          },
          "user_response_handling": {
            "if_yes": "Proceed to action S-01A-A06",
            "if_no": "Ask user which framework they prefer, re-analyze with that framework, re-present confirmation",
            "if_uncertain": "Provide additional guidance on framework tradeoffs"
          },
          "output": "User confirmation (Y/N)"
        },
        {
          "action_id": "S-01A-A06",
          "description": "User confirmed framework - load framework definition",
          "condition": "User confirmed YES in S-01A-A05",
          "command_pattern": "Read framework_registry.json and architectural_definitions_{framework}.json",
          "file_locations": [
            "{reflow_root}/definitions/framework_registry.json",
            "{reflow_root}/definitions/architectural_definitions_{selected_framework}.json"
          ],
          "note": "If custom framework selected, LLM researches domain and creates custom definitions file"
        },
        {
          "action_id": "S-01A-A07",
          "description": "Update working_memory.json with framework selection and analysis results",
          "purpose": "Document framework decision with complete rationale",
          "updates": {
            "framework_configuration": {
              "framework_id": "{selected_framework_id}",
              "framework_name": "{framework_display_name}",
              "component_term": "{node_term}",
              "connection_term": "{edge_term}",
              "architecture_file_type": "{architecture_file_type}",
              "selected_framework_rationale": "{detailed_rationale_from_A04}",
              "user_confirmed": true,
              "confirmation_timestamp": "{timestamp}"
            },
            "framework_analysis": {
              "system_characteristics": "{summary_from_A01}",
              "frameworks_evaluated": "{list_of_all_frameworks_analyzed}",
              "recommended_analyses": "{enabled_analyses_from_A03}",
              "alternatives_rejected": "{alternatives_from_A04}"
            }
          },
          "store_in": "context/working_memory.json"
        },
        {
          "action_id": "S-01A-A08",
          "description": "If custom framework: LLM research and definition creation",
          "condition": "selected_framework == 'custom'",
          "if_custom": {
            "research_steps": [
              "1. Ask user to describe the system domain and key entities",
              "2. Research domain literature (web search for 5-10 min)",
              "3. Identify common modeling approaches for this domain",
              "4. Create architectural_definitions_custom.json following pattern of other frameworks",
              "5. Create custom_node_template.json for architecture files",
              "6. User reviews and approves generated framework"
            ],
            "research_areas": [
              "Standard modeling approaches for this domain",
              "Common terminology (what are the 'nodes'? what are the 'edges'?)",
              "Validation criteria specific to this domain",
              "Quality attributes relevant to this system type"
            ],
            "output_files": [
              "{reflow_root}/definitions/architectural_definitions_custom.json",
              "{reflow_root}/templates/custom_node_template.json"
            ]
          }
        },
        {
          "action_id": "S-01A-A09",
          "description": "Display framework confirmation summary",
          "output_message": "✓ Framework selected: {framework_name}\\n✓ User confirmed: {confirmation_timestamp}\\n✓ System will use '{component_term}' nodes connected by '{connection_term}' edges\\n✓ NetworkX analyses enabled: {enabled_analyses}\\n✓ Definitions: {definitions_path}\\n✓ Template: {template_file}\\n\\nFramework selection complete. Rationale documented in working_memory.json."
        }
      ],
      "tools_used": [],
      "outputs": [
        "context/working_memory.json updated with framework selection and analysis rationale",
        "Framework analysis documented: system characteristics, alternatives evaluated, NetworkX analyses enabled",
        "Optionally: architectural_definitions_custom.json (if custom selected)"
      ],
      "gates": [
        {
          "gate_id": "G-S-01",
          "name": "Framework Selection Confirmation (BLOCKING)",
          "type": "BLOCKING",
          "severity": "critical",
          "rationale": "Framework selection is an architectural decision that determines entire analysis approach. User must explicitly confirm before proceeding.",
          "checks": [
            "System characteristics analyzed (working_memory.json framework_analysis.system_characteristics)",
            "ALL frameworks evaluated - at least 5 frameworks (working_memory.json framework_analysis.frameworks_evaluated)",
            "NetworkX analyses mapped to framework (working_memory.json framework_analysis.recommended_analyses)",
            "User explicitly confirmed framework selection (working_memory.json framework_configuration.user_confirmed == true)",
            "Detailed rationale documented (working_memory.json framework_configuration.selected_framework_rationale)"
          ],
          "failure_action": "Cannot proceed to S-02 without user confirmation. Re-execute S-01A-A05 to obtain confirmation.",
          "success_message": "✓ Framework selection confirmed by user. Rationale and analysis documented."
        }
      ],
      "next_step": "S-02",
      "notes": [
        "CRITICAL: Framework selection is NOT a default choice - it requires explicit analysis",
        "All frameworks map to the same core abstraction (nodes + edges) but enable different analyses",
        "Wrong framework = wrong insights (Example: UAF on workflows misses decision logic)",
        "Time investment: 10-15 min framework analysis saves hours of rework later",
        "Tools like system_of_systems_graph_v2.py work across all frameworks via framework adapters"
      ]
    },
    {
      "step_id": "S-02",
      "name": "Directory Structure Creation",
      "description": "Create standard system directory structure",
      "phase": "initialization",
      "step_file": "workflow_steps/setup/S-02-DirectoryStructure.json",
      "actions": [
        {
          "action_id": "S-02-A01",
          "description": "Create context/ directory",
          "purpose": "Store LLM agent tracking files (working_memory.json, step_progress_tracker.json, current_focus.md)",
          "command": "mkdir -p {system_root}/context"
        },
        {
          "action_id": "S-02-A02",
          "description": "Create specs/ directory structure",
          "purpose": "Store machine and human-readable specifications",
          "command": "mkdir -p {system_root}/specs/{machine,human}/{service_arch,interfaces,graphs,visualizations,documentation,reports}"
        },
        {
          "action_id": "S-02-A03",
          "description": "Create services/ directory",
          "purpose": "Store service implementations",
          "command": "mkdir -p {system_root}/services"
        },
        {
          "action_id": "S-02-A04",
          "description": "Create docs/ directory",
          "purpose": "Store foundational documents and system documentation",
          "command": "mkdir -p {system_root}/docs"
        },
        {
          "action_id": "S-02-A05",
          "description": "Run validate_directory_structure.py",
          "command_pattern": "python3 {reflow_root}/tools/validate_directory_structure.py {system_root}",
          "success_criteria": "All required directories exist"
        }
      ],
      "tools_used": ["validate_directory_structure.py"],
      "outputs": ["Complete system directory structure"],
      "gates": [],
      "next_step": "S-03"
    },
    {
      "step_id": "S-03",
      "name": "Foundational Documents",
      "description": "Create or validate foundational system documents",
      "phase": "initialization",
      "step_file": "workflow_steps/setup/S-03-FoundationalDocuments.json",
      "actions": [
        {
          "action_id": "S-03-A01",
          "description": "Create or validate SYSTEM_MISSION_STATEMENT.md",
          "location": "docs/SYSTEM_MISSION_STATEMENT.md",
          "content_requirements": [
            "Clear statement of system purpose",
            "Primary objectives",
            "Key stakeholders",
            "Success criteria at high level"
          ]
        },
        {
          "action_id": "S-03-A02",
          "description": "Create or validate USER_SCENARIOS.md",
          "location": "docs/USER_SCENARIOS.md",
          "content_requirements": [
            "Detailed user scenarios",
            "User personas",
            "Use cases",
            "User journey maps"
          ]
        },
        {
          "action_id": "S-03-A03",
          "description": "Create or validate SUCCESS_CRITERIA.md",
          "location": "docs/SUCCESS_CRITERIA.md",
          "content_requirements": [
            "Measurable success criteria",
            "Performance requirements",
            "Functional requirements",
            "Non-functional requirements"
          ]
        },
        {
          "action_id": "S-03-A04",
          "description": "Initialize working_memory.json",
          "tool": "bootstrap_development_context.py",
          "command_pattern": "python3 {reflow_root}/tools/bootstrap_development_context.py {system_root}",
          "creates": [
            "context/working_memory.json",
            "context/step_progress_tracker.json",
            "context/current_focus.md"
          ]
        },
        {
          "action_id": "S-03-A05",
          "description": "Initialize RAG-Enhanced Context Management (OPTIONAL but RECOMMENDED)",
          "purpose": "Set up automatic context retrieval to prevent drift and enforce workflow adherence",
          "tool": "generate_rag_embeddings.py",
          "optional": true,
          "recommended": "Strongly recommended to prevent context drift and systematic workflow enforcement",
          "setup_steps": [
            {
              "step": 1,
              "action": "Install RAG dependencies",
              "command": "pip install sentence-transformers faiss-cpu numpy",
              "check": "python3 -c 'import sentence_transformers, faiss, numpy'"
            },
            {
              "step": 2,
              "action": "Copy RAG configuration template",
              "command": "cp {reflow_root}/templates/rag_context_config_template.json {system_root}/context/rag_context_config.json"
            },
            {
              "step": 3,
              "action": "Edit RAG config and set system_name",
              "file": "{system_root}/context/rag_context_config.json",
              "update": "Set system_name field to match actual system name"
            },
            {
              "step": 4,
              "action": "Generate embeddings for knowledge bases",
              "command": "python3 {reflow_root}/tools/generate_rag_embeddings.py {system_root}",
              "creates": [
                "context/embeddings/decision_flow_embeddings.pkl",
                "context/embeddings/workflow_steps_embeddings.pkl",
                "context/embeddings/tool_reference_embeddings.pkl",
                "context/embeddings/architectural_definitions_embeddings.pkl",
                "context/embeddings/generation_summary.json"
              ],
              "duration": "1-3 minutes depending on workflow size"
            },
            {
              "step": 5,
              "action": "Verify RAG setup",
              "command": "cat {system_root}/context/embeddings/generation_summary.json",
              "success_criteria": "All knowledge bases generated successfully"
            }
          ],
          "benefits": [
            "Automatic context injection based on workflow state",
            "Degradation detection (report generation, workflow violations)",
            "Systematic enforcement of critical behavioral rules",
            "Token-efficient context retrieval (2000-8000 tokens vs 5000-10000 manual)",
            "Prevents LLM agents from forgetting workflow instructions"
          ],
          "rag_features": {
            "knowledge_bases": [
              "decision_flow_kb (workflow instructions and critical rules)",
              "workflow_steps_kb (step-specific guidance)",
              "tool_reference_kb (tool documentation)",
              "architectural_definitions_kb (UAF 1.2 terms)",
              "system_context_kb (runtime state)"
            ],
            "retrieval_strategies": [
              "on_step_start - Load workflow instructions for current step",
              "on_degradation_detected - Inject corrective context",
              "on_tool_execution - Load tool usage documentation",
              "on_user_query - Semantic search across all knowledge bases",
              "periodic_refresh - Auto-refresh every 4 operations or 12 minutes"
            ],
            "degradation_patterns": [
              "report_generation_attempt - Detects unwanted report generation",
              "workflow_violation - Detects skipping steps or ignoring workflow",
              "system_isolation_breach - Detects wrong directory or cross-system access",
              "context_confusion - Detects forgetting system name or current step"
            ]
          },
          "usage_in_workflows": {
            "manual_mode": "LLM agent manually reads working_memory.json and current_focus.md",
            "rag_enhanced_mode": "Use rag_agent_wrapper.py to automatically inject relevant context",
            "example": "python3 {reflow_root}/tools/rag_agent_wrapper.py {system_root} wrap --query 'Start next step' --strategy on_step_start"
          },
          "reference": "See {reflow_root}/docs/RAG_CONTEXT_MANAGEMENT.md for complete documentation"
        },
        {
          "action_id": "S-03-A06",
          "description": "Configure automatic git commits (OPTIONAL but RECOMMENDED)",
          "purpose": "Enable automatic version control commits at key workflow milestones",
          "user_prompt": {
            "ask": "Would you like to enable automatic git commits during workflow execution?",
            "options": [
              "Yes - Enable automatic git commits and pushes (recommended for version control)",
              "No - I'll manage git manually"
            ],
            "default": "No",
            "benefits": [
              "Automatic backup of architecture and code",
              "Version history of workflow progress",
              "Collaboration (others can see progress)",
              "Recovery from failures",
              "Meaningful commit messages at logical checkpoints"
            ]
          },
          "if_yes": {
            "git_setup": [
              {
                "step": 1,
                "action": "Check if git repo exists",
                "command": "cd {system_root} && git status",
                "outcomes": {
                  "success": "Git repo already exists, skip initialization",
                  "failure": "No git repo, proceed with initialization"
                }
              },
              {
                "step": 2,
                "action": "Initialize git repo if needed",
                "command": "cd {system_root} && git init",
                "condition": "Only if step 1 failed (no existing repo)"
              },
              {
                "step": 3,
                "action": "Create .gitignore file",
                "location": "{system_root}/.gitignore",
                "content": [
                  "# Python",
                  "__pycache__/",
                  "*.py[cod]",
                  "*$py.class",
                  "*.so",
                  ".Python",
                  "venv/",
                  "env/",
                  ".venv",
                  "*.egg-info/",
                  "",
                  "# IDEs",
                  ".vscode/",
                  ".idea/",
                  "*.swp",
                  "*.swo",
                  "*~",
                  "",
                  "# OS",
                  ".DS_Store",
                  "Thumbs.db",
                  "",
                  "# Secrets",
                  ".env",
                  "*.pem",
                  "*.key",
                  "credentials.json",
                  "",
                  "# Build artifacts",
                  "dist/",
                  "build/",
                  "*.egg",
                  "",
                  "# Test coverage",
                  ".coverage",
                  "htmlcov/",
                  "",
                  "# RAG embeddings (optional - large files)",
                  "# context/embeddings/*.pkl",
                  "",
                  "# Logs",
                  "*.log"
                ]
              },
              {
                "step": 4,
                "action": "Collect git configuration from user",
                "user_questions": [
                  {
                    "question": "What is your git remote repository URL?",
                    "examples": [
                      "https://github.com/username/repo.git",
                      "git@github.com:username/repo.git",
                      "https://gitlab.com/username/repo.git"
                    ],
                    "validation": "URL should end with .git",
                    "store_in": "context/git_config.json (git_remote_url)"
                  },
                  {
                    "question": "Which branch should automatic commits push to?",
                    "default": "main",
                    "examples": ["main", "develop", "architecture", "feature/workflow-automation"],
                    "store_in": "context/git_config.json (git_branch)"
                  },
                  {
                    "question": "Who should be credited as author for automatic commits?",
                    "default": "Claude Code <noreply@anthropic.com>",
                    "format": "Name <email>",
                    "examples": ["Claude Code <noreply@anthropic.com>", "Your Name <your@email.com>"],
                    "store_in": "context/git_config.json (git_author)"
                  }
                ]
              },
              {
                "step": 5,
                "action": "Configure git remote",
                "command": "cd {system_root} && git remote add origin {git_remote_url}",
                "fallback_if_exists": "git remote set-url origin {git_remote_url}",
                "verification": "git remote -v shows correct remote"
              },
              {
                "step": 6,
                "action": "Create initial git commit for setup",
                "commands": [
                  "cd {system_root}",
                  "git add .",
                  "git commit -m \"$(cat <<'EOF'\nInitial setup: Directory structure and foundational documents\n\n- Created directory structure (context/, specs/, docs/, services/)\n- Added foundational documents (SYSTEM_MISSION_STATEMENT.md, USER_SCENARIOS.md, SUCCESS_CRITERIA.md)\n- Initialized working_memory.json and workflow tracking\n- Configured automatic git commits\n\n🤖 Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>\nEOF\n)\"",
                  "git branch -M {git_branch}",
                  "git push -u origin {git_branch}"
                ],
                "error_handling": {
                  "if_push_fails": "Warn user but continue - they may need to configure git credentials or set up SSH keys",
                  "credential_help": "For HTTPS: git config --global credential.helper store\nFor SSH: Set up SSH keys with ssh-keygen and add to GitHub/GitLab",
                  "continue_on_failure": true
                }
              },
              {
                "step": 7,
                "action": "Save git configuration to working_memory.json",
                "update_fields": {
                  "git_automation_enabled": true,
                  "git_remote_url": "{git_remote_url}",
                  "git_branch": "{git_branch}",
                  "git_author": "{git_author}",
                  "last_git_commit": "{timestamp}"
                },
                "location": "context/working_memory.json"
              },
              {
                "step": 8,
                "action": "Create git commit helper function documentation",
                "location": "context/GIT_AUTOMATION_README.md",
                "content": "Documentation on when automatic commits occur and how to disable if needed"
              }
            ],
            "commit_schedule": {
              "description": "Automatic commits will occur at these workflow milestones",
              "00-setup": [
                "S-03-A06: After setup complete (initial commit)"
              ],
              "01-systems-engineering": [
                "SE-02: After each service architecture completed",
                "SE-06: After system graph generated and validated"
              ],
              "02-artifacts-visualization": [
                "AV-03: After human documentation generated",
                "AV-04: After visualizations created"
              ],
              "03-development": [
                "D-03: After each service foundation code completed",
                "D-03: After each service implementation completed and tests pass"
              ],
              "04-testing-operations": [
                "TO-02: After CI/CD pipeline configured",
                "TO-04: After successful deployment"
              ]
            }
          },
          "if_no": {
            "action": "Skip git setup, set git_automation_enabled: false in working_memory.json",
            "note": "User will manually manage git commits"
          },
          "llm_agent_instructions": [
            "ASK the user via AskUserQuestion tool if they want automatic git commits",
            "If YES: Execute git setup steps 1-8 in order",
            "Collect git remote URL and branch from user",
            "Create meaningful initial commit with workflow metadata",
            "Handle push failures gracefully (warn but continue)",
            "Document git configuration in working_memory.json",
            "If NO: Set git_automation_enabled: false and skip to next step"
          ],
          "success_criteria": [
            "User question asked and answered",
            "If yes: Git repo initialized/configured, initial commit made, working_memory.json updated",
            "If no: Git automation disabled in working_memory.json"
          ]
        }
      ],
      "tools_used": ["bootstrap_development_context.py", "generate_rag_embeddings.py (optional)"],
      "templates_used": [
        "working_memory_template.json",
        "step_progress_tracker_template.json",
        "current_focus_template.md",
        "rag_context_config_template.json (optional)"
      ],
      "outputs": [
        "docs/SYSTEM_MISSION_STATEMENT.md",
        "docs/USER_SCENARIOS.md",
        "docs/SUCCESS_CRITERIA.md",
        "context/working_memory.json",
        "context/step_progress_tracker.json",
        "context/current_focus.md",
        "context/git_config.json (if git automation enabled)",
        ".gitignore (if git automation enabled)"
      ],
      "gates": [
        {
          "gate_id": "G-S-03",
          "name": "Foundational Documents Complete",
          "checks": [
            "All three foundational documents exist",
            "Documents contain meaningful content (not just templates)",
            "working_memory.json initialized with correct paths"
          ]
        }
      ],
      "next_step": "S-04-decision"
    },
    {
      "step_id": "S-04-decision",
      "name": "System-of-Systems Decision",
      "description": "Determine if this is a system-of-systems integration project",
      "phase": "initialization",
      "decision_type": "user_input",
      "question": "Is this a system-of-systems integration project (multiple independent systems that need to work together)?",
      "options": {
        "yes": {
          "description": "Multi-system integration required",
          "next_step": "S-04"
        },
        "no": {
          "description": "Single system or standard service decomposition",
          "next_step": "complete",
          "transition_to": "01-systems_engineering"
        }
      }
    },
    {
      "step_id": "S-04",
      "name": "System-of-Systems Decomposition (Optional)",
      "description": "Decompose high-level concept into multiple independent systems",
      "phase": "initialization",
      "optional": true,
      "step_file": "workflow_steps/setup/S-04-SystemOfSystems.json",
      "when_to_use": "Multi-system integration projects where systems have independent lifecycles",
      "actions": [
        {
          "action_id": "S-04-A01",
          "description": "Analyze system-of-systems requirements",
          "purpose": "Identify independent systems that need integration",
          "creates": "Initial system-of-systems breakdown"
        },
        {
          "action_id": "S-04-A02",
          "description": "Define system boundaries",
          "purpose": "Clarify which capabilities belong to which system",
          "output": "System boundary definitions"
        },
        {
          "action_id": "S-04-A03",
          "description": "Identify integration points",
          "purpose": "Understand how systems will interact",
          "tool": "identify_integration_points.py (may be used later)"
        },
        {
          "action_id": "S-04-A04",
          "description": "Create separate system directories",
          "purpose": "Each system gets its own directory structure",
          "pattern": "Create {system_root}/../{system_name}/ for each identified system"
        }
      ],
      "tools_used": [],
      "outputs": [
        "Multiple system directories (one per system)",
        "System-of-systems documentation in docs/",
        "Integration requirements documented"
      ],
      "gates": [],
      "next_step": "complete",
      "transition_to": "01-systems_engineering",
      "note": "Each identified system will go through workflows independently, then integrate"
    }
  ],
  "completion": {
    "description": "Setup workflow complete - system is ready for architecture phase",
    "outputs_summary": [
      "System directory structure created",
      "All paths configured and validated",
      "Foundational documents created",
      "Context tracking initialized",
      "Optional: System-of-systems decomposed"
    ],
    "next_workflow": "01-systems_engineering",
    "transition_command": "workflow_driver.py {system_root} --next-workflow"
  },
  "llm_agent_guidance": {
    "critical_reminders": [
      "ALWAYS use absolute paths when invoking tools: python3 {reflow_root}/tools/<tool>.py {system_root}",
      "Store all path configuration in context/working_memory.json for future reference",
      "Verify reflow_root contains required directories before proceeding",
      "Never assume system is located in reflow/systems/ - it can be anywhere",
      "Use workflow_driver.py to track progress through setup steps"
    ],
    "common_mistakes": [
      "Using relative paths for tool invocation (causes 'file not found' errors)",
      "Not validating reflow_root directory structure",
      "Skipping foundational documents (causes issues in later workflows)",
      "Not initializing working_memory.json with path configuration"
    ]
  }
}
